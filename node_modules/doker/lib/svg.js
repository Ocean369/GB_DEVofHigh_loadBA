// Generated by CoffeeScript 1.9.3
(function() {
  var Svg, fs, xml2js;

  fs = require('fs');

  xml2js = require('xml2js');

  Svg = (function() {
    function Svg(fileName, document) {
      var data, def, grad, i, id, j, k, len, len1, len2, matrix, num, ref, ref1, ref2, sizes, stop, x1, x2, xml, y1, y2;
      this.fileName = fileName;
      this.document = document;
      data = fs.readFileSync(this.fileName).toString();
      xml = [];
      xml2js.parseString(data, function(err, result) {
        return xml = result;
      });
      this.xml = xml;
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
      this.gradients = [];
      if (this.xml.svg.$.viewBox != null) {
        sizes = this.xml.svg.$.viewBox.match(/([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)/);
        if (sizes != null) {
          this.x = parseFloat(sizes[1]);
          this.y = parseFloat(sizes[2]);
          this.width = parseFloat(sizes[3]);
          this.height = parseFloat(sizes[4]);
        }
      }
      if (this.xml.svg.defs != null) {
        ref = this.xml.svg.defs;
        for (i = 0, len = ref.length; i < len; i++) {
          def = ref[i];
          if (def.linearGradient != null) {
            ref1 = def.linearGradient;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              grad = ref1[j];
              id = grad.$.id;
              x1 = parseFloat(grad.$.x1);
              x2 = parseFloat(grad.$.x2);
              y1 = parseFloat(grad.$.y1);
              y2 = parseFloat(grad.$.y2);
              matrix = grad.$.gradientTransform.match(/matrix\(([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\)/);
              this.gradients[id] = this.document.linearGradient(x1, y1, x2, y2);
              if (matrix != null) {
                this.gradients[id].transform = (function() {
                  var k, len2, ref2, results;
                  ref2 = matrix.slice(1);
                  results = [];
                  for (k = 0, len2 = ref2.length; k < len2; k++) {
                    num = ref2[k];
                    results.push(parseFloat(num));
                  }
                  return results;
                })();
              }
              ref2 = grad.stop;
              for (k = 0, len2 = ref2.length; k < len2; k++) {
                stop = ref2[k];
                this.gradients[id].stop(stop.$.offset, stop.$['stop-color']);
              }
            }
          }
        }
      }
    }

    Svg.prototype._toPt = function(value) {
      var result;
      result = value.match(/([-+]?[0-9]*\.?[0-9]+)mm/);
      if (result != null) {
        return parseFloat(result[1]) / 0.3527;
      }
      result = value.match(/([-+]?[0-9]*\.?[0-9]+)pt/);
      if (result != null) {
        return parseFloat(result[1]);
      }
      return parseFloat(value);
    };

    Svg.prototype.draw = function(x, y, options) {
      var f;
      if (x == null) {
        x = this.document.x;
      }
      if (y == null) {
        y = this.document.y;
      }
      if (options == null) {
        options = {};
      }
      f = 1.0;
      if (options.width != null) {
        f = options.width / this.width;
      }
      if (options.height != null) {
        f = options.height / this.height;
      }
      if (options.align != null) {
        switch (options.align) {
          case 'center':
            x -= f * this.width / 2;
            break;
          case 'right':
            x -= f * this.width;
        }
      }
      if (options.valign != null) {
        switch (options.valign) {
          case 'center':
            y -= f * this.height / 2;
            break;
          case 'bottom':
            y -= f * this.height;
        }
      }
      this.document.save().translate(x - this.x * f, y - this.y * f).scale(f);
      this._group(this.xml.svg);
      return this.document.restore();
    };

    Svg.prototype._group = function(g) {
      var child, circle, i, j, k, len, len1, len2, matrix, path, subg, tag, translation;
      this.document.save();
      if ((g.$ != null) && (g.$.transform != null)) {
        translation = g.$.transform.match(/translate\(([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\)/);
        matrix = g.$.transform.match(/matrix\(([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\s+([-+]?[0-9]*\.?[0-9]+)\)/);
        if (translation != null) {
          this.document.translate(parseFloat(translation[1]), parseFloat(translation[2]));
        }
        if (matrix != null) {
          this.document.transform(parseFloat(matrix[1]), parseFloat(matrix[2]), parseFloat(matrix[3]), parseFloat(matrix[4]), parseFloat(matrix[5]), parseFloat(matrix[6]));
        }
      }
      for (child in g) {
        tag = g[child];
        if (child === 'circle') {
          for (i = 0, len = tag.length; i < len; i++) {
            circle = tag[i];
            this._circle(circle, g);
          }
        }
        if (child === 'path') {
          for (j = 0, len1 = tag.length; j < len1; j++) {
            path = tag[j];
            this._path(path, g);
          }
        }
        if (child === 'g') {
          for (k = 0, len2 = tag.length; k < len2; k++) {
            subg = tag[k];
            this._group(subg);
          }
        }
      }
      return this.document.restore();
    };

    Svg.prototype._path = function(path, g) {
      var grad;
      this.document.path(path.$.d);
      if (path.$.fill != null) {
        grad = path.$.fill.match(/url\(#([a-bA-B0-9])\)/);
        if (grad != null) {
          return this.document.fill(this.gradients[grad[1]]);
        } else {
          return this.document.fill(path.$.fill);
        }
      } else if ((g.$ != null) && (g.$.fill != null)) {
        return this.document.fill(g.$.fill);
      }
    };

    Svg.prototype._circle = function(circle, g) {
      this.document.circle(parseFloat(circle.$.cx), parseFloat(circle.$.cy), parseFloat(circle.$.r));
      if ((circle.$ != null) && (circle.$.fill != null)) {
        return this.document.fill(circle.$.fill);
      } else if ((g.$ != null) && (g.$.fill != null)) {
        return this.document.fill(g.$.fill);
      }
    };

    return Svg;

  })();

  module.exports = Svg;

}).call(this);
