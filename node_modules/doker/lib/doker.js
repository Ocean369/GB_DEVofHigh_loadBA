// Generated by CoffeeScript 1.9.3
(function() {
  var Doker, DokerTheme, PDFDocument, fs,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  PDFDocument = require('pdfkit');

  fs = require('fs');

  DokerTheme = require('./doker_theme');

  Doker = (function(superClass) {
    var mixin;

    extend(Doker, superClass);

    function Doker(theme) {
      var k, options, ref, v;
      this.theme = theme || new DokerTheme;
      this.theme.setDocument(this);
      this.pageNumberAliases = [];
      this.pageNumber = 0;
      options = {
        bufferPages: true,
        wordSpacing: true
      };
      if (this.theme.options.margin != null) {
        options.margin = this.theme.options.margin;
      }
      if (this.theme.options.margins != null) {
        options.margins = this.theme.options.margins;
      }
      Doker.__super__.constructor.call(this, options);
      if (this.theme.options.author != null) {
        this.info.Author = this.theme.options.author;
      }
      this.info.Creator = 'Doker';
      this._parseArgs();
      this.pipe(fs.createWriteStream(this.output));
      if (this.theme.options.fonts != null) {
        ref = this.theme.options.fonts;
        for (k in ref) {
          v = ref[k];
          this.registerFont(k, v);
        }
      }
      this._headers = [];
      this._elements = [];
      return this;
    }

    mixin = function(methods) {
      var method, name, results;
      results = [];
      for (name in methods) {
        method = methods[name];
        results.push(Doker.prototype[name] = method);
      }
      return results;
    };

    mixin(require('./mixins/cc'));

    mixin(require('./mixins/formatting'));

    mixin(require('./mixins/markdown'));

    mixin(require('./mixins/outlines'));

    mixin(require('./mixins/pages'));

    mixin(require('./mixins/svg'));

    mixin(require('./mixins/table'));

    mixin(require('./mixins/toc'));

    Doker.prototype._parseArgs = function() {
      var arg, args, i, j, len, results;
      args = process.argv.slice(2);
      results = [];
      for (i = j = 0, len = args.length; j < len; i = ++j) {
        arg = args[i];
        if (arg === '-o' || arg === '--output') {
          this.output = args[i + 1];
        }
        if (arg === '-v' || arg === '--version') {
          results.push(this.productVersion = args[i + 1]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Doker.prototype.addPage = function(options) {
      if (options == null) {
        options = this.options;
      }
      this.pageNumber = this._pageBuffer.length;
      if (this.pageNumber === 0 || (this.pageNumberAliases[this.pageNumber - 1] == null)) {
        this.pageNumberAliases[this.pageNumber] = this.pageNumber + 1;
      } else {
        this.pageNumberAliases[this.pageNumber] = this.pageIncrement(this.pageNumberAliases[this.pageNumber - 1]);
      }
      Doker.__super__.addPage.call(this, options);
      this.theme.apply();
      this.left = this.page.margins.left;
      this.cx = this.page.width / 2;
      this.right = this.page.width - this.page.margins.right;
      this.top = this.page.margins.top;
      this.cy = this.page.height / 2;
      this.bottom = this.page.height - this.page.margins.bottom;
      this.width = this.right - this.left;
      this.height = this.bottom - this.top;
      return this;
    };

    Doker.prototype.arc = function(cx, cy, r, startAngle, endAngle) {
      var cw, delta, dx, dy, flags, x, y;
      cw = startAngle > endAngle;
      delta = Math.abs(endAngle - startAngle);
      if (delta > 180) {
        flags = cw ? '1,1' : '1,0';
      } else {
        flags = cw ? '0,1' : '0,0';
      }
      startAngle = startAngle * Math.PI / 180;
      endAngle = endAngle * Math.PI / 180;
      x = cx + r * Math.cos(startAngle);
      y = cy - r * Math.sin(startAngle);
      dx = r * (Math.cos(endAngle) - Math.cos(startAngle));
      dy = -r * (Math.sin(endAngle) - Math.sin(startAngle));
      return this.path("M " + x + "," + y + " a " + r + "," + r + " 0 " + flags + " " + dx + "," + dy);
    };

    Doker.prototype.codeFile = function(fileName) {
      var data;
      data = fs.readFileSync(fileName).toString();
      return this.code(data);
    };

    Doker.prototype.end = function() {
      this._endToc();
      this._endPages();
      Doker.__super__.end.apply(this, arguments);
      return this._endOutlines();
    };

    return Doker;

  })(PDFDocument);

  module.exports = Doker;

}).call(this);
